import ast
import logging
import dataclasses as dc
from pathlib import Path
import enum
from typing import Tuple, Dict, Union, Optional

# import docutils.core
#
import markdown2
# import yaml


log = logging.getLogger()



class LitteralException(Exception):
    pass


class InvalidLitteralValue(LitteralException):
    pass


class LitterateType(enum.IntEnum):
    RST = enum.auto()
    MD = enum.auto()


@dc.dataclass
class Litterate:
    title : str = ""
    summary : str = ""
    body : str = ""  # <- generated by md2litterate (md or html) or rst2litterate (html)
    raw : str = ""
    meta : dict = dc.field(default_factory=dict)
    kind : Optional[LitterateType] = None


def get_doc(txt: str) -> str:
    """extracts the __doc__ part in a txt (python code)

    Args:
        txt (str): string to be parsed as python script

    Returrns:
        str - string extracted from __doc__
    """
    class MyVisitor(ast.NodeVisitor):
        def visit_Module(self, node):
            self.doc = ast.get_docstring(node)

    visitor = MyVisitor()
    visitor.visit(ast.parse(txt))
    doc = getattr(visitor, 'doc', None) or ''
    return doc


def load_doc(path: Path) -> str:
    """loads and extract the __doc__ part from path

    Args:
        path (Path): file location
    Returns:
        str - docstring from path
    """
    return get_doc(path.read_text())


def popmeta(txt: str, parse:bool = True, tag="== endmeta ==") -> Tuple[Union[str,Dict[str, str]], str]:
    """extract from str all lines up to endmeta
    
    Args:
        txt: text to extract from
        parse: process meta into a dictionary
        tag: marks the end of the "meta" section
    Returns:
        dict, str: tuple of metadata dict and text    
    """
    from markdown2 import Markdown

    meta = None
    text = []
    status = None
    for line in txt.split("\n"):
        if status is None:
            if line.strip() == tag:
                status = "text"
            else:
                status = "meta"
                meta = [line]
        elif status == "text":
            text.append(line)
        else:
            if line.strip() == tag:
                status = "text"
            else:
                meta.append(line)
    textpart = "\n".join(text)
    metapart = "\n".join(meta)
    if parse:
        md = Markdown(extras=['metadata'])
        md.convert("\n".join(["---", *meta, "---"]))
        metapart = getattr(md, "metadata", None)
    return metapart, textpart


def md2lit(txt: str) -> Litterate:
    """process a markdown doc string into metadata and html"""
    from markdown2 import Markdown
    md = Markdown(extras=['metadata'])

    lit = Litterate()
    lit.meta, lit.raw = popmeta(txt, parse=True)
    lit.body = md.convert(lit.raw)
    lit.kind = LitterateType.MD
    return lit


def rst2lit(txt: str) -> Litterate:
    """process txt (rst) into a data and html"""
    from docutils.core import publish_parts, publish_doctree
    root = publish_doctree(source=txt)


    lit = Litterate()
    lit.raw = txt

    #lit, lines = any2litterate(txt)
    # we extract the body part (it should have all the __doc__ rendered
    #root = publish_parts(source=txt, writer_name="html")
    #lit.body = root["body"]
    #lit.mode = "html"
    return lit
